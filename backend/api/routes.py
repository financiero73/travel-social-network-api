# Auto-generated by Lumenary
##############################################################################
# Dependencies
##############################################################################


from fastapi import Depends, FastAPI, HTTPException, Request, status, Body, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import HTMLResponse, Response

from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse, Response
from fastapi.exceptions import RequestValidationError
from fastapi.security import OAuth2PasswordBearer

import sys
import os
import asyncio
import logging
import traceback
import contextvars
import httpx
import jwt
import json
import requests
from pathlib import Path
import builtins

from datetime import datetime, date, time, timedelta
from concurrent.futures import ThreadPoolExecutor
from typing import Callable, Any, TypeVar, Awaitable, List, Optional, Dict, Union, Literal, Annotated, Tuple, Set
from functools import partial, wraps
from uuid import UUID
import uuid

# from solar.access import User
# from solar.media import MediaFile

from api.utils import get_swagger_ui_html
from api.models import TokenExchangeRequest, TokenResponse, TokenValidationRequest, LogoutResponse

OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")
ROUTER_BASE_URL = os.environ.get("ROUTER_BASE_URL")
SOLAR_APP_TOKEN_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/token"
SOLAR_APP_INTROSPECT_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/introspect"
REFRESH_TOKEN_COOKIE_NAME = "refresh_token"





from .models import BodySocialServicesGetSocialFeed, GetSocialFeedOutputSchema, BodySocialServicesLikePost, LikePostOutputSchema, BodySocialServicesSavePostToWishlist, SavePostToWishlistOutputSchema, BodySocialServicesFollowUser, FollowUserOutputSchema, BodySocialServicesGetUserSavedPosts, GetUserSavedPostsOutputSchema, BodySocialServicesGetSavedLocations, GetSavedLocationsOutputSchema, BodySocialServicesCreateTravelPost, CreateTravelPostOutputSchema, BodyAIServicesGenerateTripRecommendations, GenerateTripRecommendationsOutputSchema, BodySocialServicesCreateReview, CreateReviewOutputSchema, BodySocialServicesGetPostReviews, GetPostReviewsOutputSchema, BodySocialServicesUpdateReview, UpdateReviewOutputSchema, BodySocialServicesDeleteReview, DeleteReviewOutputSchema, BodySocialServicesVoteReview, VoteReviewOutputSchema
from core import social_services
from core import ai_services


###############################################################################
# Logging Setup
###############################################################################
import sys
from loguru import logger
from pathlib import Path
from typing import TypeVar
import traceback

def format_record(record):
    fmt = "{level:<5} | {message}"
    if record["exception"] is not None:
        exc_type, exc_value, exc_traceback = record["exception"]        
        tb_lines = traceback.extract_tb(exc_traceback)
        if tb_lines:
            last_frame = tb_lines[-1]
            error_info = (
                f'\nFile "{last_frame.filename}", line {last_frame.lineno}, in {last_frame.name}\n'
                f'  {last_frame.line}\n'
                f'{exc_type.__name__}: {exc_value}'
            )
            record["message"] += error_info
        
        record["exception"] = None
    
    return fmt + "\n"

logger.remove()
logger.add(
    sys.stderr,
    level="DEBUG",
    format=format_record,
    colorize=True
)

Path("../logs").mkdir(exist_ok=True)
logger.add(
    "../logs/fast_api.log",
    rotation="50 MB",
    retention="10 days",
    level="DEBUG",
    format=format_record
)

# need this to capture print statements
class InterceptHandler:
    def write(self, msg):
        if msg.strip():
            logger.info(msg.strip())
    
    def flush(self):
        pass

sys.stdout = InterceptHandler()

T = TypeVar('T')



##############################################################################
# General App
##############################################################################

app = FastAPI(
    title="New app — 8/15 @ 4:56 PM",
    docs_url=None
)

###############################################################################
# Simple Request Logging Middleware
###############################################################################

@app.middleware("http")
async def log_requests(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    
    with logger.contextualize(request_id=request_id):
        start_time = datetime.utcnow()
        
        try:
            response = await call_next(request)
            process_time = (datetime.utcnow() - start_time).total_seconds()
            if "HEAD /docs" not in request.url.path:
              logger.info(f"{request.method} {request.url.path} ({response.status_code}) - {process_time:.3f}s")
            return response
        except Exception as e:
            process_time = (datetime.utcnow() - start_time).total_seconds()
            logger.exception(f"{request.method} {request.url.path} - Failed after {process_time:.3f}s")
            raise
            
###############################################################################
# Error Handler
###############################################################################
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors"""
    logger.error(f"Unhandled exception on {request.method} {request.url.path}: {exc}", exc_info=True)
    
    # In production, don't expose error details
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred"
        }
    )
    
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle pydantic validation errors"""
    logger.error(f"Validation error on {request.url.path}: {exc.errors()}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "message": "Invalid request parameters",
            "details": exc.errors()
        }
    )
    
@app.exception_handler(Exception)
async def handle_errors(request: Request, exc: Exception):
    logger.exception(f"Unhandled error: {type(exc).__name__}: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error", "message": str(exc)}
    )

@app.exception_handler(RequestValidationError)
async def handle_validation_errors(request: Request, exc: RequestValidationError):
    logger.warning(f"Validation error: {exc.errors()}")
    return JSONResponse(
        status_code=422,
        content={"error": "Validation failed", "details": exc.errors()}
    )

# We need to put a token endpoint here, but we're injecting the token,
# so we'll just put a mock endpoint here.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/mockedTokenEndpoint/")
ENV = os.environ.get("ENV", "deployment")

def get_auth_origins():
    if ENV == "sandbox":
        origins = [
            os.environ.get("SANDBOX_FRONTEND_URL", ""),
            os.environ.get("SANDBOX_BACKEND_URL", ""),
        ]
    else:
        origins = [os.environ.get("PUBLIC_DOMAIN", "")]
    
    return [origin for origin in origins if origin]

# Configuración de CORS permisiva para desarrollo
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=False,  # Debe ser False cuando allow_origins=["*"]
    allow_methods=["*"],
    allow_headers=["*"],
)

# El middleware de autenticación se comenta temporalmente para evitar conflictos de CORS
# async def auth_cors_middleware(request: Request, call_next):
#     if request.url.path.startswith("/api/auth"):
#         auth_origins = get_auth_origins()
#         origin = request.headers.get("origin", "")
#         response = await call_next(request)
        
#         # override the wildcard CORS settings with strict origin checking
#         if origin in auth_origins:
#             response.headers["Access-Control-Allow-Origin"] = origin
#             response.headers["Access-Control-Allow-Credentials"] = "true"
#             response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
#             response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
#             response.headers["Access-Control-Expose-Headers"] = "Set-Cookie"
#         else:
#             # unauthorized origins on auth routes, set CORS headers to blank or remove them
#             response.headers["Access-Control-Allow-Origin"] = ""
#             response.headers["Access-Control-Allow-Methods"] = ""
#             response.headers["Access-Control-Allow-Headers"] = ""
            
#         return response
#     else:
#         return await call_next(request)

# # auth-specific middleware and logging middleware
# app.middleware("http")(auth_cors_middleware)

# OPTIONS handler for auth endpoints
@app.options("/api/auth/{rest_of_path:path}", include_in_schema=False)
async def auth_options_handler(request: Request):
    auth_origins = get_auth_origins()
    origin = request.headers.get("origin", "")
    response = Response()
    
    if origin in auth_origins:
        response.headers["Access-Control-Allow-Origin"] = origin
        response.headers["Access-Control-Allow-Credentials"] = "true"
        response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
        response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
        response.headers["Access-Control-Max-Age"] = "3600"
    
    return response

@app.head("/docs", include_in_schema=False)
async def health_check():
    return {"status": "healthy"}
    
##############################################################################
# Synchronous Function Helpers
##############################################################################

thread_pool = ThreadPoolExecutor(max_workers=4)

async def run_sync_in_thread(func: Callable[..., Any], *args, **kwargs) -> Any:
    """Runs a synchronous function in a thread pool"""
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(
        thread_pool,
        partial(func, *args, **kwargs)
    )


##############################################################################
# Custom Docs
##############################################################################

@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " on Solar",
        swagger_ui_parameters={
            "persistAuthorization": False,
            "syntaxHighlight": {"theme": "obsidian"},
        }
    )

##############################################################################
# Auth Routes
##############################################################################

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        base_url = os.getenv("ROUTER_BASE_URL")
        if not base_url:
            raise HTTPException(status_code=500, detail="ROUTER_BASE_URL is not set, could not authenticate user")
        
        try:
            decoded_token = jwt.decode(token, options={"verify_signature": False})
            
            jti = decoded_token.get("jti")
            if not jti:
                raise HTTPException(status_code=401, detail="Invalid token format")
            
            exp = decoded_token.get("exp")
            if exp is not None and exp < datetime.utcnow().timestamp():
                raise HTTPException(status_code=401, detail="Token expired")
        
        except jwt.DecodeError:
            raise HTTPException(status_code=401, detail="Malformed token")
        
        token_url = f"{base_url}/innerApp/oauth2/introspect"
        async with httpx.AsyncClient(timeout=20.0) as client:
            response = await client.post(token_url, json={"token": jti, "token_type_hint": "access_token"})
            if response.status_code != 200:
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            json_response = response.json()
            if not json_response.get("active", False):
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            user_uuid = json_response.get("userUuid")
            email = json_response.get("email")
            if not user_uuid or not email:
                raise HTTPException(status_code=401, detail="Invalid user data")
            
            user = User(id=user_uuid, email=email)
            return user
    except HTTPException:
        raise
    except Exception as e:
        print(f"get_current_user failed with error: {type(e).__name__}")
        raise HTTPException(status_code=401, detail="Unauthorized")

def extract_domain(url):
    if not url:
        return None
    
    # Remove protocol
    if url.startswith("http://"):
        url = url[7:]
    elif url.startswith("https://"):
        url = url[8:]
    
    # Remove trailing slash
    if url.endswith("/"):
        url = url[:-1]
    
    return url

@app.post('/api/auth/token', response_model=TokenResponse, include_in_schema=False)
async def exchange_token(request: Request, body: TokenExchangeRequest = Body(...)):    
    try:
        params = body.model_dump(exclude_none=True)
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME:
            refresh_token = request.cookies.get(REFRESH_TOKEN_COOKIE_NAME)
            if not refresh_token:
                return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authentication required",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )

            params[REFRESH_TOKEN_COOKIE_NAME] = refresh_token
        
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME and params.get(REFRESH_TOKEN_COOKIE_NAME):
            try:
                refresh_token = params[REFRESH_TOKEN_COOKIE_NAME]
                payload = jwt.decode(refresh_token, options={"verify_signature": False})
                
                if payload and payload.get("jti"):
                    params[REFRESH_TOKEN_COOKIE_NAME] = payload["jti"]
            except Exception as e:
                logger.warning("Error extracting JTI from refresh token")

        response = requests.post(
            SOLAR_APP_TOKEN_URL,
            json=params,
            headers={"Content-Type": "application/json", "Accept": "application/json"}
        )
        
        if not response.ok:
            return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authorization code invalid or expired",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )
        
        tokens = response.json()
        
        # Safe null check for access token
        access_token = tokens.get("access_token")
        if not access_token:
            return HTTPException(status_code=401, detail="Received incomplete token data from server")
        
        token_response = TokenResponse(
            access_token=access_token,
            token_type=tokens.get("token_type", "bearer"),
            expires_in=tokens.get("expires_in", 3600)
        )
        
        content = token_response.model_dump()
        api_response = JSONResponse(content=content)
        
        # Safe null check for refresh token
        refresh_token_value = tokens.get(REFRESH_TOKEN_COOKIE_NAME)
        if refresh_token_value:
            if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
              return HTTPException(status_code=401, detail="Token exchange failed: sandbox frontend URL not set")
            
            if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
              return HTTPException(status_code=401, detail="Token exchange failed: public domain not set")
            
            domain = None
            if ENV == "sandbox":
                domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
            else:
                domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))

            api_response.set_cookie(
                key=REFRESH_TOKEN_COOKIE_NAME,
                value=refresh_token_value,
                httponly=True,
                secure=True,
                samesite="none" if ENV == "sandbox" else "strict",
                domain=domain,
                path="/api/auth"
            )
        
        return api_response
        
    except Exception as e:
        return HTTPException(status_code=401, detail=f"Token exchange failed: {str(e)}")


@app.post('/api/auth/logout', response_model=LogoutResponse, include_in_schema=False)
async def logout():
    response = JSONResponse(content={"success": True})
    
    if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
      return HTTPException(status_code=401, detail="Logout failed: sandbox frontend URL not set")
    
    if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
      return HTTPException(status_code=401, detail="Logout failed: public domain not set")
    
    domain = None
    if ENV == "sandbox":
        domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
    else:
        domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))
    
    response.delete_cookie(
        key=REFRESH_TOKEN_COOKIE_NAME,
        path="/api/auth",
        secure=True,
        httponly=True,
        samesite="none" if ENV == "sandbox" else "strict",
        domain=domain,
    )
    
    return response


##############################################################################
# Normal Routes
##############################################################################






@app.post('/api/social_services/get_social_feed', response_model=GetSocialFeedOutputSchema, operation_id='social_services_get_social_feed')
async def social_services_get_social_feed(body: BodySocialServicesGetSocialFeed = Body(...)) -> GetSocialFeedOutputSchema:
    """
    Get Instagram-style social feed for a user based on who they follow.
    """
    response = await run_sync_in_thread(social_services.get_social_feed, user_id=body.user_id, page=body.page, limit=body.limit)
    return response
    
    




@app.post('/api/social_services/like_post', response_model=LikePostOutputSchema, operation_id='social_services_like_post')
async def social_services_like_post(body: BodySocialServicesLikePost = Body(...)) -> LikePostOutputSchema:
    """
    Like or unlike a post.
    """
    response = await run_sync_in_thread(social_services.like_post, user_id=body.user_id, post_id=body.post_id)
    return response
    
    




@app.post('/api/social_services/save_post_to_wishlist', response_model=SavePostToWishlistOutputSchema, operation_id='social_services_save_post_to_wishlist')
async def social_services_save_post_to_wishlist(body: BodySocialServicesSavePostToWishlist = Body(...)) -> SavePostToWishlistOutputSchema:
    """
    Save a post to user&#39;s wishlist.
    """
    response = await run_sync_in_thread(social_services.save_post_to_wishlist, user_id=body.user_id, post_id=body.post_id, collection_name=body.collection_name, notes=body.notes)
    return response
    
    




@app.post('/api/social_services/follow_user', response_model=FollowUserOutputSchema, operation_id='social_services_follow_user')
async def social_services_follow_user(body: BodySocialServicesFollowUser = Body(...)) -> FollowUserOutputSchema:
    """
    Follow or unfollow a user.
    """
    response = await run_sync_in_thread(social_services.follow_user, follower_id=body.follower_id, following_id=body.following_id)
    return response
    
    




@app.post('/api/social_services/get_user_saved_posts', response_model=GetUserSavedPostsOutputSchema, operation_id='social_services_get_user_saved_posts')
async def social_services_get_user_saved_posts(body: BodySocialServicesGetUserSavedPosts = Body(...)) -> GetUserSavedPostsOutputSchema:
    """
    Get user&#39;s saved posts organized by location/collection.
    """
    response = await run_sync_in_thread(social_services.get_user_saved_posts, user_id=body.user_id, location_filter=body.location_filter, collection_filter=body.collection_filter)
    return response
    
    




@app.post('/api/social_services/get_saved_locations', response_model=GetSavedLocationsOutputSchema, operation_id='social_services_get_saved_locations')
async def social_services_get_saved_locations(body: BodySocialServicesGetSavedLocations = Body(...)) -> GetSavedLocationsOutputSchema:
    """
    Get unique locations from user&#39;s saved posts for organization.
    """
    response = await run_sync_in_thread(social_services.get_saved_locations, user_id=body.user_id)
    return response
    
    




@app.post('/api/social_services/create_travel_post', response_model=CreateTravelPostOutputSchema, operation_id='social_services_create_travel_post')
async def social_services_create_travel_post(body: BodySocialServicesCreateTravelPost = Body(...)) -> CreateTravelPostOutputSchema:
    """
    Create a new travel post.
    """
    response = await run_sync_in_thread(social_services.create_travel_post, user_id=body.user_id, caption=body.caption, images=body.images, location_name=body.location_name, country=body.country, post_type=body.post_type, category=body.category, tags=body.tags, city=body.city, booking_info=body.booking_info)
    return response
    
    


@app.post('/api/ai_services/generate_trip_recommendations', response_model=GenerateTripRecommendationsOutputSchema, operation_id='ai_services_generate_trip_recommendations')
async def ai_services_generate_trip_recommendations(body: BodyAIServicesGenerateTripRecommendations = Body(...)) -> GenerateTripRecommendationsOutputSchema:
    """
    Genera recomendaciones de viaje basadas en los objetivos del usuario.
    """
    response = await run_sync_in_thread(ai_services.generate_trip_recommendations, user_id=body.user_id, goals=body.goals, location=body.location, duration=body.duration)
    return response


# ==================== REVIEWS ENDPOINTS ====================

@app.post('/api/social_services/create_review', response_model=CreateReviewOutputSchema, operation_id='social_services_create_review')
async def social_services_create_review(body: BodySocialServicesCreateReview = Body(...)) -> CreateReviewOutputSchema:
    """
    Create a review for a post.
    """
    response = await run_sync_in_thread(social_services.create_review, user_id=body.user_id, post_id=body.post_id, rating=body.rating, comment=body.comment)
    return response


@app.post('/api/social_services/get_post_reviews', response_model=GetPostReviewsOutputSchema, operation_id='social_services_get_post_reviews')
async def social_services_get_post_reviews(body: BodySocialServicesGetPostReviews = Body(...)) -> GetPostReviewsOutputSchema:
    """
    Get all reviews for a post with pagination.
    """
    response = await run_sync_in_thread(social_services.get_post_reviews, post_id=body.post_id, page=body.page, limit=body.limit)
    return response


@app.post('/api/social_services/update_review', response_model=UpdateReviewOutputSchema, operation_id='social_services_update_review')
async def social_services_update_review(body: BodySocialServicesUpdateReview = Body(...)) -> UpdateReviewOutputSchema:
    """
    Update a user's own review.
    """
    response = await run_sync_in_thread(social_services.update_review, user_id=body.user_id, review_id=body.review_id, rating=body.rating, comment=body.comment)
    return response


@app.post('/api/social_services/delete_review', response_model=DeleteReviewOutputSchema, operation_id='social_services_delete_review')
async def social_services_delete_review(body: BodySocialServicesDeleteReview = Body(...)) -> DeleteReviewOutputSchema:
    """
    Delete a user's own review (soft delete).
    """
    response = await run_sync_in_thread(social_services.delete_review, user_id=body.user_id, review_id=body.review_id)
    return response


@app.post('/api/social_services/vote_review', response_model=VoteReviewOutputSchema, operation_id='social_services_vote_review')
async def social_services_vote_review(body: BodySocialServicesVoteReview = Body(...)) -> VoteReviewOutputSchema:
    """
    Vote on whether a review is helpful or not.
    """
    response = await run_sync_in_thread(social_services.vote_review, user_id=body.user_id, review_id=body.review_id, is_helpful=body.is_helpful)
    return response


# ==================== DATABASE MIGRATION ENDPOINT ====================

@app.post('/api/admin/migrate_database')
async def admin_migrate_database():
    """
    Run database migrations to fix schema issues and create new tables.
    WARNING: This should only be run once!
    """
    from solar.table import get_pool
    
    try:
        pool = get_pool()
        pg_keys = list(pool.keys())
        
        if not pg_keys:
            return {"error": "No database connection available"}
        
        pg_key = pg_keys[0]  # Use first available connection
        
        results = []
        
        with pool[pg_key].getconn() as conn:
            with conn.cursor() as cursor:
                # Fix saved_posts table
                try:
                    cursor.execute("""
                        SELECT column_name 
                        FROM information_schema.columns 
                        WHERE table_name='saved_posts' AND column_name='location_category'
                    """)
                    if cursor.fetchone():
                        cursor.execute("ALTER TABLE saved_posts DROP COLUMN IF EXISTS location_category CASCADE")
                        results.append("✅ Removed location_category from saved_posts")
                    else:
                        results.append("ℹ️ location_category already removed")
                except Exception as e:
                    results.append(f"⚠️ Error fixing saved_posts: {str(e)}")
                
                # Fix follows table
                try:
                    cursor.execute("""
                        SELECT column_name 
                        FROM information_schema.columns 
                        WHERE table_name='follows' AND column_name='notification_enabled'
                    """)
                    if cursor.fetchone():
                        cursor.execute("ALTER TABLE follows DROP COLUMN IF EXISTS notification_enabled CASCADE")
                        results.append("✅ Removed notification_enabled from follows")
                    else:
                        results.append("ℹ️ notification_enabled already removed")
                except Exception as e:
                    results.append(f"⚠️ Error fixing follows: {str(e)}")
                
                # Create reviews table
                try:
                    cursor.execute("""
                        CREATE TABLE IF NOT EXISTS reviews (
                            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                            post_id UUID NOT NULL,
                            user_id UUID NOT NULL,
                            rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
                            comment TEXT,
                            helpful_count INTEGER DEFAULT 0,
                            created_at TIMESTAMP DEFAULT NOW(),
                            updated_at TIMESTAMP DEFAULT NOW(),
                            is_active BOOLEAN DEFAULT TRUE,
                            UNIQUE(user_id, post_id)
                        )
                    """)
                    results.append("✅ Created reviews table")
                except Exception as e:
                    results.append(f"⚠️ Error creating reviews: {str(e)}")
                
                # Create review_votes table
                try:
                    cursor.execute("""
                        CREATE TABLE IF NOT EXISTS review_votes (
                            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                            review_id UUID NOT NULL,
                            user_id UUID NOT NULL,
                            is_helpful BOOLEAN NOT NULL,
                            created_at TIMESTAMP DEFAULT NOW(),
                            is_active BOOLEAN DEFAULT TRUE,
                            UNIQUE(user_id, review_id)
                        )
                    """)
                    results.append("✅ Created review_votes table")
                except Exception as e:
                    results.append(f"⚠️ Error creating review_votes: {str(e)}")
                
                # Commit all changes
                conn.commit()
                results.append("✅ Migration completed successfully!")
        
        return {"success": True, "results": results}
    
    except Exception as e:
        return {"success": False, "error": str(e), "traceback": traceback.format_exc()}
